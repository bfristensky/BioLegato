/* Generated By:JJTree&JavaCC: Do not edit this line. PCD.java */
package org.biopcd.parser ;

import java.awt.image.BufferedImage ;
import java.io.File                 ;
import java.io.Reader               ;
import java.io.FileReader           ;
import java.io.FileInputStream      ;
import java.io.IOException          ;
import java.io.InputStreamReader    ;
import java.io.BufferedReader       ;
import java.sql.Connection          ;
import java.sql.DriverManager       ;
import java.util.Set                ;
import java.util.Map                ;
import java.util.List               ;
import java.util.HashSet            ;
import java.util.HashMap            ;
import java.util.ArrayList          ;
import java.util.Collection         ;
import java.util.Collections        ;
import java.util.LinkedList         ;
import java.util.LinkedHashMap      ;
import java.util.regex.Matcher      ;
import java.util.regex.Pattern      ;
import javax.swing.Action           ;
import javax.swing.BoxLayout        ;
import javax.swing.JButton          ;
import javax.swing.JFrame           ;
import javax.swing.JMenu            ;
import javax.swing.JList            ;
import javax.swing.JPanel           ;
import javax.swing.JSlider          ;
import javax.swing.JTabbedPane      ;
import javax.swing.JTextField       ;
import javax.swing.JMenuItem        ;
import javax.swing.ImageIcon        ;
import javax.imageio.ImageIO        ;
import org.biopcd.sql.*             ;
import org.biopcd.widgets.*         ;
//import org.biopcd.parser.PreProcess.*;

// Resources
// http://anandsekar.github.io/writing-an-interpretter-using-javacc/
// https://www.computing.dcu.ie/~davids/courses/CA4003/CA4003_JJTree_2p.pdf
// https://javacc.org/jjtree
// http://cps710.scs.ryerson.ca/Material/Quigley/JJTree/JJTree.pdf
// https://www.youtube.com/watch?v=9V4GzEomc5w

// http://www.softwaresecretweapons.com/jjtree.html
// http://harunkamau.blogspot.com/2014/11/using-javacc-to-generate.html

/**
 * <p>A class used to parse PCD files into BioLegato.</p>
 *
 * <p><u>The modified EBNF specification of the PCD files read by this parser is
 *    as follows:</u></p>
 * <pre>{@code
 * parseFullMenu  ::= ( indent(scope) <T_MENU> <WSP> menuName=<TEXT> nl()
 *                         ( indent(scope + 1) <T_ITEM> nl() parseMenuItem() )+
 *                    )+
 * parseMenuItem  ::= [ nl() ]
 *                      indent(scope) <T_CMDNAME> <WSP> <TEXT> nl()
 *                    [ indent(scope) <T_ICON>    <WSP> <TEXT> nl() ]
 *                    [ indent(scope) <T_TIP>     <WSP> <TEXT> nl() ]
 *                    [ indent(scope) <T_SYS>   ( <WSP> SystemName() nl() | nl()
 *                                ( indent(scope + 1)   SystemName() nl() )+ ) ]
 *                    [ indent(scope) <T_EXEC>    <WSP> <TEXT> nl() ]
 *                    [ indent(scope) ParseDBConnect()  nl() ]
 *                      Body(scope, pcdio)
 * Body           ::= ( Content(scope) )* [ <EOF> ]
 * Content        ::= ( Param(scope) | Act (scope)
 *                    | Tab (scope) | Panel(scope) )
 * Tab            ::=   indent(scope) <T_TABSET> nl()
 *                    ( indent(scope + 1) ( <T_TAB> <WSP> <TEXT> nl()
 *                         ( indent(scope + 2) Content(scope + 2) )+
 *                    )+
 * Panel          ::=   indent(scope) <T_PANEL> nl()
 *                    ( indent(scope + 1) Content(scope) )+ )+
 * Act            ::=   indent(scope)
 *                      <T_ACT>     <WSP> <TEXT> nl() indent(scope + 1)
 *                      <T_SHELL>   <WSP> <TEXT> nl()
 *                    [ indent(scope + 1) <T_CLOSE>   <WSP> Bool() nl() ]
 * Param          ::=   indent(scope) <T_PARAM> <WSP> name=<TEXT> nl()
 *                      indent(scope + 1) <T_TYPE>  <WSP>
 *                    (
 *                      <T_BUTTON>   nl() buttonFields   (scope + 1)
 *                    | <T_CHOOSER>  nl() listFields     (scope + 1)
 *                    | <T_COMBOBOX> nl() listFields     (scope + 1)
 *                    | <T_LIST>     nl() listFields     (scope + 1)
 *                    | <T_TEXT>     nl() textFields     (scope + 1)
 *                    | <T_TEXTAREA> nl() textAreaFields (scope + 1)
 *                    | <T_NUMBER>   nl() numberFields   (scope + 1)
 *                    | <T_DECIMAL>  nl() decimalFields  (scope + 1)
 *                    | <T_FILE>     nl() fileFields     (scope + 1)
 *                    | <T_DIR>      nl() dirFields      (scope + 1)
 *                    | <T_TEMPFILE> nl() tempfileFields (scope + 1)
 *                    )
 * buttonFields   ::=   indent(scope)
 *                    [ <T_LABEL>     <WSP> <TEXT> nl() indent(scope) ]
 *                      <T_SHELL>     <WSP> <TEXT> nl()
 *                    [ indent(scope) <T_CLOSE>     <WSP> Bool() nl() ]
 * listFields     ::=   indent(scope)
 *                    [ <T_LABEL>     <WSP> <TEXT>   nl() indent(scope) ]
 *                    [ <T_DEFAULT>   <WSP> <NUMBER> nl() indent(scope) ]
 *                      <T_CHOICES>
 *                      ( <WSP> ( <T_QUERY> <WSP> <TEXT>
 *                      | FullSQLQuery() ) nl()
 *                      | nl() ( indent(scope + 1) <TEXT> <WSP> <TEXT> nl() )+ )
 * textFields     ::= [ indent(scope) <T_LABEL>   <WSP> <TEXT> nl() ]
 *                    [ indent(scope) <T_DEFAULT> <WSP> <TEXT> nl() ]
 * textAreaFields ::= [ indent(scope) <T_LABEL>   <WSP> <TEXT> nl() ]
 *                    [ indent(scope) <T_DEFAULT> <WSP> <TEXT> nl() ]
 *                    [ indent(scope) <T_SAVE>    <WSP> Bool() nl() ]
 * numberFields   ::=   indent(scope)
 *                      <T_LABEL>     <WSP> <TEXT>    nl() indent(scope)
 *                      <T_MIN>       <WSP> <NUMBER>  nl() indent(scope)
 *                      <T_MAX>       <WSP> <NUMBER>  nl()
 *                    [ indent(scope) <T_DEFAULT>   <WSP> <NUMBER>  nl() ]
 * decimalFields  ::=   indent(scope)
 *                    [ <T_LABEL>     <WSP> <TEXT>    nl() indent(scope) ]
 *                      <T_MIN>       <WSP> Decimal() nl() indent(scope)
 *                      <T_MAX>       <WSP> Decimal() nl()
 *                    [ indent(scope) <T_DEFAULT>   <WSP> Decimal() nl() ]
 * fileFields     ::=   indent(scope) <T_LABEL>   <WSP> <TEXT> nl()
 *                    [ indent(scope) <T_DEFAULT> <WSP> <TEXT> nl() ]
 * dirFields      ::=   indent(scope) <T_LABEL>   <WSP> <TEXT> nl()
 *                    [ indent(scope) <T_DEFAULT> <WSP> <TEXT> nl() ]
 * tempfileFields ::=   indent(scope) <T_DIRECTION> <WSP>
 *                                ( <T_IN> | <T_OUT> ) nl()
 *                      indent(scope) <T_FORMAT>    <WSP> FileFormat()  nl()
 *                    [ indent(scope) <T_SAVE>      <WSP> Bool()  nl() ]
 *                    [ indent(scope) <T_OVERWRITE> <WSP> Bool() nl() ]
 *                    [ indent(scope) <T_CONTENT>   <WSP>
 *                                ( <T_CANVAS> | <T_SELECTION> ) nl() ]
 * ParseDBConnect ::=   <T_DATABASE> <WSP>
 *                    ( DBDriver() <WSP> DBURL()  [ <WSP> DBLogin() ]
 *                    | <T_MYSQL>  <WSP> DBURL()
 *                                 <WSP> DBName() [ <WSP> DBLogin() ]
 *                    | <T_HSQLDB> <WSP> DBURL()  [ <WSP> DBLogin() ]
 *                    )
 * DBLogin        ::=   <T_LOGIN> <WSP> DBUser() <WSP> DBPassword()
 * DBURL          ::=   <TEXT>
 * DBDriver       ::=   <TEXT>
 * DBUser         ::=   <TEXT>
 * DBPassword     ::=   <TEXT>
 * FullSQLQuery   ::=   ParseDBConnect() <WSP> <T_QUERY> <WSP> <TEXT>
 * FileFormat     ::= ( <T_CSV> | <T_TSV> | <T_FASTA> | <T_FLAT> | <T_GDE>
 * 		      | <T_GENBANK> | <T_RAW> | <T_MASK> | <TEXT> )
 * SystemName     ::= ( <T_ALL> | <T_LINUX> | <T_OSX> | <T_SOLARIS>
 * 	              | <T_UNIX> | <T_WINDOWS> ) [ <WSP> ArchList () ]
 * ArchList       ::=   ArchName() ( [ <WSP> ] <COMMA> [ <WSP> ] ArchName() )*
 * ArchName       ::= ( <T_ALL> | <T_X86> | <T_AMD64> | <T_SPARC> )
 * Decimal        ::= ( t=<DECIMAL> | value = <NUMBER> )
 * Bool           ::= ( <T_TRUE> | <T_FALSE> )
 * nl             ::= [ <WSP> ] ( <NL> | <EOF> )
 * }</pre>
 *
 * <p><i>NOTE: in JavaCC indentation is handled by
 *      <code>LOOKAHEAD({testIndent(scope)})</code>, and
 *      <code>assetIndent(scope)</code>.  To simplify the EBNF code above, I
 *      have replaced both instances with a pseudo-function "indent", which does
 *      not exist.  Additionally, DBLogin, DBUser, DBURL, DBName, DBPassword and
 *      DBDriver were created for the EBNF to assist readers with interpreting
 *      the semantics of the EBNF.  In the JavaCC code, the DBLogin, DBUser,
 *      DBURL, DBName, DBPassword and DBDriver productions are done inline
 *      (instead of in a separate function).</i></p>
 *
 * <p><u>The token symbols for the parser are as follows
 *       (as context dependent regular expressions):</u></p>
 * <pre>{@code
 * 1. Tokens which can be read in any context, but switch the context to DATA
 *    when parsed:
 *        T_BUTTON    ::= "button"
 *        T_CHOOSER   ::= "chooser"
 *        T_COMBOBOX  ::= "combobox"
 *        T_DECIMAL   ::= "decimal"
 *        T_DIR       ::= "dir"
 *        T_FILE      ::= "file"
 *        T_LIST      ::= "list"
 *        T_NUMBER    ::= "number"
 *        T_TEXT      ::= ( "text" | "textbox" )
 *        T_TEXTAREA  ::= "textarea"
 *        T_TEMPFILE  ::= "tempfile"
 *        T_LINUX     ::= "linux"
 *        T_OSX       ::= "osx"
 *        T_SOLARIS   ::= "solaris"
 *        T_UNIX      ::= "unix"
 *        T_WINDOWS   ::= "windows"
 *        T_X86       ::= ( "x86" | "intel" )
 *        T_AMD64     ::= ( "amd64" | "x86_64")
 *        T_SPARC     ::= "sparc"
 *        T_FALSE     ::= "false"
 *        T_TRUE      ::= "true"
 *        T_CSV       ::= "csv"
 *        T_TSV       ::= "tsv"
 *        T_FASTA     ::= "fasta"
 *        T_FLAT      ::= "flat"
 *        T_GDE       ::= "gde"
 *        T_GENBANK   ::= "genbank"
 *        T_RAW       ::= "raw"
 *        T_MASK      ::= "colormask"
 *        T_IN        ::= "in"
 *        T_OUT       ::= "out"
 *        T_CHECK     ::= "check"
 *        T_CHOICES   ::= "choices"
 *        T_CLOSE     ::= "close"
 *        T_CONTENT   ::= "content"
 *        T_DIRECTION ::= "direction"
 *        T_FORMAT    ::= "format"
 *        T_MAX       ::= "max"
 *        T_MIN       ::= "min"
 *        T_OVERWRITE ::= "overwrite"
 *        T_TYPE      ::= "type"
 *        T_SAVE      ::= "save"
 *        T_SHELL     ::= "shell"
 *        T_ICON      ::= "icon"
 *        T_SYS       ::= "system"
 *        T_TIP       ::= "tip"
 *        T_CANVAS    ::= "canvas"
 *        T_SELECTION ::= "selection"
 *        T_AND       ::= "and"
 *        T_IF        ::= "if"
 *        T_OR        ::= "or"
 *        T_THEN      ::= "then"
 *        T_XOR       ::= "xor"
 *        T_QUERY     ::= "query"
 *        T_DATABASE  ::= "database"
 *        T_JDBC      ::= "jdbc"
 *        T_MYSQL     ::= "mysql"
 *        T_HSQLDB    ::= ( "hsql" | "hsqldb" )
 *        T_LOGIN     ::= "login"
 *        T_PROMPT    ::= "prompt"
 *        T_ALL       ::= "all"
 *        T_DEFAULT   ::= "default"
 *        T_EXEC      ::= "exec"
 *        T_LABEL     ::= "label"
 *        T_ITEM      ::= "item"
 *        T_MENU      ::= "menu"
 *        T_CMDNAME   ::= "name"
 *        T_ACT       ::= "act"
 *        T_PARAM     ::= "var"
 *        T_TABSET    ::= "tabset"
 *        T_TAB       ::= "tab"
 *        T_PANEL     ::= "panel"
 *        COMMA       ::= ","
 *        TEXT        ::= "\"([^\"]|\"\")*\""
 *        DECIMAL     ::= "\-?([0-9]+)?.[0-9]+"
 *        NUMBER      ::= "\-?[0-9]+"
 *        ENVVAR      ::== "$"(["a"-"z","A"-"Z"])(["a"-"z","A"-"Z","_","0"-"9", "."])*"
 *        ID          ::= "(["a"-"z","A"-"Z"])(["a"-"z","A"-"Z","_","0"-"9", "."])*"
 *
 * 2. Tokens which can only be read in the DATA context (and do NOT switch the
 *    context when read):
 *        WSP ::= ( <SP>  | <TAB> )+  >
 *
 * 3. Tokens which can only be read in the DATA context and switch the context
 *    to DEFAULT when read:
 *        NL  ::= ( <EOL> | <COEL> )
 *
 * 4. Tokens to be skipped in the DEFAULT context (and do NOT switch the context
 *    when read):
 *        EOL    ::= "\r\n"
 *        TAB    ::= "\t"
 *        INDENT ::= " {4}"   // NOTE: this increments scope in DEFAULT context!
 *        JUNKSP ::= " {1,3}" // ANY non-divisible by 4 spacing before a line.
 *
 * 5. Tokens to be skipped in any context, and switch the context to DEFAULT
 *    when read:
 *        COMMENT ::= "#[^\n\r]+" }</pre>
 *
 * <p><i>NOTE: the DEFAULT context refers to any leading space before a token is
 *             read; the data context refers to anything read after the first
 *             non-whitespace token on a line.  We use two contexts because
 *             whitespace at the beginning of a line can affect scope, while
 *             whitespace in the middle of a line only delimits fields.
 *             Specifically, 4 space characters at the beginning of a line
 *             increments the level of scope by one.</i></p>
 *
 */
public class PCD/*@bgen(jjtree)*/implements PCDTreeConstants, PCDConstants {/*@bgen(jjtree)*/
  protected JJTPCDState jjtree = new JJTPCDState();/**
     * An enumeration representing all of the operating systems
     * detectable by BioLegato.
     */
    public static enum OS {

        /**
         * Represents any non-Mac OS X BSD UNIX operating system.
         */
        BSD,
        /**
         * Represents any Linux operating system.
         */
        LINUX,
        /**
         * Represents any HP-UX operating system.
         */
        HP_UX,
        /**
         * Represents any non-OS X Mac OS operating system.
         */
        MACOS,
        /**
         * Represents any Mac OS X operating system.
         */
        OSX,
        /**
         * Represents any Solaris operating system.
         */
        SOLARIS,
        /**
         * Represents any Windows 9X operating system (Windows 95, 98, and ME).
         */
        WINDOWS_9X,
        /**
         * Represents any Windows NT operating system (NT, 2000, and above).
         */
        WINDOWS_NT,
        /**
         * Represents any generic UNIX operating system (other than what is
         * specified above).
         */
        UNIX;

        /**
         * Returns true is the current operating system is Windows-based.
         */
        public boolean isWindows() {
            return (this == WINDOWS_9X || this == WINDOWS_NT);
        }

        /**
         * Returns true is the current operating system is UNIX-based.
         */
        public boolean isUNIX() {
            return (this != WINDOWS_9X && this != WINDOWS_NT);
        }

        /**
         * Detects the current operating system
         * Check out: http://lopica.sourceforge.net/os.html
         **
         * @return the current operating system
         */
        public static OS detectOS() {
            OS result = UNIX;
            String osName = System.getProperty("os.name").toLowerCase();

            if (osName.startsWith("windows")) {
                result = WINDOWS_NT;
                if (osName.startsWith("windows 9")
                        || osName.equals("windows me")) {
                    result = WINDOWS_9X;
                }
            } else if (osName.startsWith("solaris")
                    || osName.startsWith("sunos")) {
                result = SOLARIS;
            } else if (osName.startsWith("linux")) {
                result = LINUX;
            } else if (osName.endsWith("bsd")) {
                result = BSD;
            } else if (osName.startsWith("hp-ux")) {
                result = HP_UX;
            } else if (osName.startsWith("mac os x")) {
                result = OSX;
            } else if (osName.startsWith("mac os")) {
                result = MACOS;
            } else {
                System.err.println("Did not detect your OS!"
                        + "  Defaulting to UNIX -- "
                        + " system: " + System.getProperty("os.name")
                        + "   version: " + System.getProperty("os.version"));
            }
            return result;
        }
    }
    /**
     * An enumeration representing all of the system architectures
     * detectable by BioLegato.
     */
    public static enum ARCH {

        /**
         * Represents any X86 32-bit compatible CPU.
         */
        X86,
        /**
         * Represents any AMD 64-bit (64-bit X86) compatible CPU.
         */
        AMD64,
        /**
         * Represents any ALPHA-compatible CPU.
         */
        ALPHA,
        /**
         * Represents any ARM-compatible CPU.
         */
        ARM,
        /**
         * Represents any MIPS-compatible CPU.
         */
        MIPS,
        /**
         * Represents any SPARC-compatible CPU.
         */
        SPARC,
        /**
         * Represents any 32-bit PowerPC-compatible CPU.
         */
        PPC,
        /**
         * Represents any 64-bit PowerPC-compatible CPU.
         */
        PPC64,
        /**
         * Represents any unknown architecture CPU.
         */
        UNKNOWN;

        /**
         * Detects the current system architecture
         * Check out: http://lopica.sourceforge.net/os.html
         **
         * @return the current system architecture
         */
        public static ARCH detectARCH() {
            ARCH result = UNKNOWN;
            String osArch = System.getProperty("os.arch").toLowerCase();

            if (osArch.equals("sparc")) {
                result = SPARC;
            } else if (osArch.equals("arm")) {
                result = ARM;
            } else if (osArch.equals("alpha")) {
                result = ALPHA;
            } else if (osArch.equals("mips")) {
                result = MIPS;
            } else if (osArch.equals("amd64") || osArch.equals("x86_64")) {
                result = AMD64;
            } else if (osArch.equals("x86") || (osArch.startsWith("i")
                        && osArch.endsWith("86"))) {
                result = X86;
            } else if (osArch.equals("ppc") || osArch.startsWith("power")) {
                if (!osArch.endsWith("64")) {
                    result = PPC;
                } else {
                    result = PPC64;
                }
            } else {
                System.err.println("Did not detect your system architecture: "
                    + System.getProperty("os.arch"));
            }
            return result;
        }
    }
    /**
     * Stores the current operating system
     */
    public static final OS CURRENT_OS = OS.detectOS();
    /**
     * Stores the current machine architecture
     */
    public static final ARCH CURRENT_ARCH = ARCH.detectARCH();
    /**
     * The widget list to use for running the current PCD command.
     * This is used for replacing any command line variables.
     */
    private Map<String, Widget> masterWidgetList;
    /**
     * The main database to connect to for the SQL queries within PCD file
     */
    private JDBCDBConnection mainConnection = null;
    /**
     * Whether to operate in debug mode
     */
    public static boolean debug = false;
    /**
     * An enumeration to store which type of list to create using list
     * parameters. To elaborate, this enumeration is utilized because
     * the listParameter method, which reads in the parameters for any
     * PCD list, is reused for comboboxes, choosers and choice lists.
     */
    public static enum ListType {
        CHOOSER,
        COMBOBOX,
        LIST;
    }
    /**
     * The current directory to use for open and save file choosers.
     * This variable will cache the last opened directory, so as to
     * maintain consistency.
     */
    private static File currentPWD = new File(System.getProperty("user.dir"));

    /**
     * Parses a PCD file into its corresponding PCDObject.
     **
     * @param path   the path for the file
     * @param canvas the canvas for the PCD menu to interact with
     */
    public static PCDObject loadPCDFile (File path, PCDIO canvas)
                                            throws IOException, ParseException {
        // Opens a reader object and calls an alternative form of this method.
        return loadPCDStream(new FileReader(path),
                path.getParentFile(), canvas);
    }

    /**
     * Parses a PCD input stream into its corresponding PCDObject
     **
     * @param in     the reader object to read the menu from.
     * @param path   the path for the file.
     * @param canvas the canvas for the PCD menu to interact with.
     */
    public static PCDObject loadPCDStream (Reader in, File path, PCDIO canvas)
                                            throws IOException, ParseException {
        // Create a PCD parser object.
        PCD parser = new PCD(in);

        // Read in the menu item from the stream.
        return parser.parseMenuItem(0, path, canvas);
    }

    /**
     * Loads a path of PCD files into BioLegato
     **
     * @param path   the relative path of the PCD file(s) to load
     *               - used for making the command path relative
     * @param menu   the object to store all menu items
     * @param canvas the parent canvas of the PCD menu items
     * @param parent the parent window for displaying the PCD menu items in
     */
    public static void loadPCDPath (File path,
            Map<String,Map<String, PCDObject>> menu,
            PCDIO canvas, JFrame parent) {
        // A File object used to determine whether or not a pcd_order file
        // is located in the current directory.  If it is, this object also
        // is used for reading the pcd_order file.
        File orderfile;
        // "Test path" - this string is used for determining the extension of
        // the current path being read.  The path is converted to lower case
        // to avoid case sensitivity of the file extension.
        String tpath = path.getAbsolutePath().toLowerCase();

        if (path.exists() && path.canRead()) {
            ///////////////
            // RECURSION //
            ///////////////
            // 1.  if the path parameter is  a directory, loop through all
            //     of the files and subdirectories stored in path, and run
            //     loadPCD path on them.
            // 2.  if the path parameter is a file, read the PCD file.
            if (path.isDirectory()) {
                ////////////////////////////////
                // CASE: PARSE FILE DIRECTORY //
                ////////////////////////////////
                // BRANCH:
                //  A) If a pcd_order file exists, load the menu files in the
                //     order specified in the pcd_order file.  Read any files
                //     NOT specified in the PCD order file afterwards.
                //
                //  B) If no pcd_order file exists, read the menu item files in
                //     the order they are returned from: path.listFiles()
                //         -- this will likely be alphabetical order.
                ////////////////////////////////

                // Set the order file object to the expected path of the
                // pcd_order file within the directory.
                orderfile = new File(path, "pcd_order");

                // Test if the pcd_order file exists.
                if (orderfile.exists() && orderfile.isFile()
                                       && orderfile.canRead()) {
                    try {
                        // The set of files read from the pcd_order file.
                        // This object is used at the end of this method to
                        // ensure that files are not read twice, when this
                        // method reads all of the files in the directory
                        // which are not specified in the pcd_order file
                        Set    fset = new HashSet();
                        // The current file specified by the pcd_order file.
                        File   ofile;
                        // The current (raw) line read in from the pcd_order
                        // file.
                        String line;
                        // The buffered reader used to read the pcd_order file.
                        BufferedReader oread
                                = new BufferedReader(new FileReader(orderfile));

                        // Iterate through the pcd_order file, line by line.
                        while ((line = oread.readLine()) != null) {
                            // Skip any blank lines.
                            if (!line.trim().equals("")) {
                                // Create a new File object to handle the path
                                // specified by the current line in the file.
                                ofile = new File(path, line);

                                // Test if the path, specified on the current
                                // line in the pcd_order file, points to a
                                // real (and readable) path.
                                if (ofile.exists() && ofile.canRead()) {
                                    // If the path is a directory, then add a
                                    // new menu to the hashtable of menus.
                                    if (ofile.isDirectory()
                                            || line.endsWith("/")) {
                                        menu.put(line, new LinkedHashMap<String,
                                                                  PCDObject>());
                                    }

                                    // Load any PCD menu files specified by the
                                    // path (or inside the path, if the path
                                    // is a directory).  Then, add the path's
                                    // File object to 'fset', to ensure we do
                                    // not load the file twice.
                                    loadPCDPath(ofile, menu, canvas, parent);
                                    fset.add(ofile);
                                }
                            }
                        }
                        // Handle any paths in the current directory, which were
                        // not parsed by pcd_order.  This method will utilize
                        // the 'fset' variable.
                        for (File sdir : path.listFiles()) {
                            if (!fset.contains(sdir)) {
                                loadPCDPath(sdir, menu, canvas, parent);
                            }
                        }
                    } catch (IOException ioe) {
                        // Display an error message if any errors occur while
                        // loading PCD menus from the current directory.
                        System.err.println("BioPCD: Error reading pcd_order, "
                                         + "skipping pcd_order preferences!");
                        ioe.printStackTrace(System.err);
                        for (File subdir : path.listFiles()) {
                            loadPCDPath(subdir, menu, canvas, parent);
                        }
                    }
                } else {
                    for (File subdir : path.listFiles()) {
                        loadPCDPath(subdir, menu, canvas, parent);
                    }
                }
            } else if (tpath.endsWith(".pcd")    || tpath.endsWith(".blitem")
                    || tpath.endsWith(".blmenu") || tpath.endsWith(".biopcd")) {
                // PARSE A PCD MENU FILE
                try {

                    // Call includePCD to insert includes into the blmenu file
                    File temp1 = PreProcess.includePCD(path);

                    // Open PCD menu file.
                    //FileReader infile = new FileReader(path);
                    FileReader infile = new FileReader(temp1);

                    // Create a new PCD object to store the PCD data read in
                    // from the PCD menu file, and parse the menu file into the
                    // PCD menu object.
                    PCDObject pcdo = loadPCDStream (infile, path.getParentFile(), canvas);

                    // If the PCD menu object parsed is not null (i.e. the PCD
                    // menu file was read successfully), then add the menu to
                    // the list of menus loaded into BioLegato.
                    if (pcdo != null) {
                        menuAdd(menu, path.getParentFile().getName(), pcdo);
                    }

                    // If the DEBUG MODE flag is set, print that the parse was
                    // successful (which is the case if we reach this line).
                    if (debug) {
                        System.out.println("BioPCD: PARSE OK!  Loaded " + path);
                    }
                } catch (Throwable th) {
                    // Print an error message if the parse failed.
                    System.err.println("PARSE FAILED! - " + path);
                    th.printStackTrace(System.err);
                    System.err.flush();
                    System.err.flush();
                }
            }
        } else if (path.isDirectory() || tpath.endsWith(".pcd")
                                      || tpath.endsWith(".blitem")) {
            // Handles paths which do not point to PCD files,
            // nor point to directories.
            System.out.println("ERROR - cannot read \u005c""
                    + path.getAbsolutePath() + "\u005c"");
        }
    }

    /**
     * Adds a PCD menu item object to the list of menu items hashtable.
     **
     * @param menu     the menu hashtable to add the item to.
     * @param menuName the name of the menu within the hash to add the item to.
     * @param pcdo     the PCD menu item object to add to the menu.
     */
    private static void menuAdd (Map<String,Map<String, PCDObject>> menu,
            String menuName, PCDObject pcdo) {
        if (pcdo != null) {
            if (!menu.containsKey(menuName)) {
                menu.put(menuName, new LinkedHashMap<String, PCDObject>());
            }
            menu.get(menuName).put(pcdo.name, pcdo);
        }
    }

    /**
     * Parses a text string and converts environment variables to their
     * corresponding values (e.g. replace $home with the user's home
     * directory path).
     **
     * @param tokenstr the string to parse
     * @return the parsed string
     */
    public static String textString (String tokenstr) {
        String retstr = "";
        Pattern p = Pattern.compile("\u005c"\u005c\u005c$([a-zA-Z])([a-zA-Z_\u005c\u005c-0-9@\u005c\u005c.])*\u005c"");
        Matcher m = p.matcher(tokenstr);

        if ( m.matches() ) {
            String teststr = tokenstr.substring(2,tokenstr.length()-1);
            String envstr = System.getenv(teststr);
            if (envstr == null) {
                retstr = "";
            } else {
                retstr=envstr;
            }
            //System.out.println(retstr);
        } else {
            retstr = tokenstr.substring(1,tokenstr.length() - 1).replaceAll("\u005c"\u005c"", "\u005c"");
        }
        //return tokenstr; 
        return retstr;
   }
   /**
     * Gets the present working directory "PWD" for all PCD widgets
     * (this does NOT change CURRENT_DIR!)  This value can be used to
     * cache which directory file dialog boxes should use as their
     * "current working directory"
     **
     * @return the current value of "PWD"
     */
    public static File getCurrentPWD() {
        return currentPWD;
    }

    /**
     * Sets the present working directory "PWD" for all PCD widgets
     * (this does NOT change CURRENT_DIR!)  This value can be used to
     * cache which directory file dialog boxes should use as their
     * "current working directory"
     **
     * @param newPWD the new directory to use as the "PWD"
     */
    public static void setCurrentPWD(File newPWD) {
        currentPWD = newPWD;
    }

    public class PCDMetaTokenManager extends PCDTokenManager {
        PCDMetaTokenManager(SimpleCharStream s) {
            super(s);
        }

        public Token getNextToken() {
            return super.getNextToken();
        }
    }

/******************************************************************************/


/**************************************************************
 *   _____               _            _   _                   *
 *  |  __ \             | |          | | (_)                  *
 *  | |__) | __ ___   __| |_   _  ___| |_ _  ___  _ __  ___   *
 *  |  ___/ '__/ _ \ / _` | | | |/ __| __| |/ _ \| '_ \/ __|  *
 *  | |   | | | (_) | (_| | |_| | (__| |_| | (_) | | | \__ \  *
 *  |_|   |_|  \___/ \__,_|\__,_|\___|\__|_|\___/|_| |_|___/  *
 *                                                            *
 **************************************************************/

/**
 * <p>Parses a PCD menu.</p>
 * <p>The format for a PCD menu is:</p>
 * <pre>
 *      menu Name
 *      MenuItem data</pre>
 **
 * @param menuMap  the menu hashtable to add the menus and menu items to.
 * @param scope    the indentation scope to parse the objects in.
 * @param home     the relative path of the PCD file(s) to load
 *                 - used for making the command paths relative.
 * @param canvas   the parent canvas of the PCD menu items.
 * @param parent   the parent window for displaying the PCD menu items in.
 */
  final public void parseFullMenu(Map<String,Map<String, PCDObject>> menuMap, int scope,
                   File home, PCDIO canvas, JFrame parent) throws ParseException {
 /*@bgen(jjtree) parseFullMenu */
    ASTparseFullMenu jjtn000 = new ASTparseFullMenu(JJTPARSEFULLMENU);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* The name of the menu */
    String menuName;
    try {
      label_1:
      while (true) {
        jj_consume_token(T_MENU);
        jj_consume_token(WSP);
        menuName = Text();
        nl();
        label_2:
        while (true) {
          jj_consume_token(T_ITEM);
          nl();
                        try {
                            menuAdd(menuMap, menuName,
                                    parseMenuItem(scope + 2, home, canvas));
                        } catch (ParseException ex) {
                            System.out.println("FAILED PARSE OF MENU ITEM" +
                                               " --- SKIPPING AHEAD!");
                            ex.printStackTrace(System.err);
                            Token skipto;
                            do {
                                skipto = getNextToken();
                            } while (skipto.kind != T_ITEM
                                && skipto.kind != T_MENU
                                && skipto.kind != EOF);
                        }
          if (testIndent(scope + 1)) {
            ;
          } else {
            break label_2;
          }
        }
        if (testIndent(scope)) {
          ;
        } else {
          break label_1;
        }
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

/**
 * <p>Parses a PCD menu item.</p>
 * <p>The format for a PCD menu item is:</p>
 * <pre>
 *     Header
 *     Content</pre>
 * <p>The format for a PCD menu item header is:</p>
 * <pre>
 *     [ Optional Blank Space ]
 *     [ PCD Options ]
 *     Tabs and Parameters</pre>
 * <p>Currently supported PCD options:</p>
 * <table>
 * <tr><th>Option name</th><th>Description</th></tr>
 * <tr><td>name</td>       <td>the name of the PCD command</td></tr>
 * <tr><td>tip</td>        <td>the tool-tip text for the PCD command</td></tr>
 * <tr><td>icon</td>       <td>the path of the PCD command's icon file</td></tr>
 * <tr><td>system</td>     <td>a list of supported system configurations
 *                             for the PCD command</td></tr>
 * </table>
 **
 * @param  scope the indentation scope to parse the objects in
 * @param  path the parent directory of the menu being read.
 * @param  pcdio the PCD I/O object for all temporary files to interact with
 * @return the PCD object represented by the menu item
 */
  final public PCDObject parseMenuItem(int scope, File path, PCDIO pcdio) throws ParseException {
 /*@bgen(jjtree) parseMenuItem */
    ASTparseMenuItem jjtn000 = new ASTparseMenuItem(JJTPARSEMENUITEM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/**
     * The menu item name for the current PCD file program
     */
    String  name              = null  ;
    /**
     * If the exec parameter in a PCD file is set, this variable will
     * also be set.  This variable is used to run commands which do not
     * have any associated display widgets.  If this is variable is not
     * null, the command will run once the menu button is pressed.  The
     * command used for running will be stored in this variable.
     */
    String  exec              = null  ;
    /**
     * The menu item icon for the current PCD file program
     */
    String  icon              = null  ;
    /**
     * The menu item tooltip text for the current PCD file program
     */
    String  tooltip           = null  ;
    /**
     * Stores which systems the current PCD file is supported on
     */
    Set<SystemToken> systems  = new HashSet<SystemToken>();
    /* the token to store all of the information received about the option */
    Token t;
    /* A list of widgets parsed for the menu item's creation */
    Map<String,Widget> widgetList;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 0:
      case NL:
      case WSP:
        nl();
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      if (testIndent(scope)) {

      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(T_CMDNAME);
      jj_consume_token(WSP);
                            name    = Text();
      nl();
      if (testIndent(scope) && getToken(1).kind == T_ICON) {
        jj_consume_token(T_ICON);
        jj_consume_token(WSP);
                            icon    = Text();
        nl();
      } else {
        ;
      }
      if (testIndent(scope) && getToken(1).kind == T_TIP) {
        jj_consume_token(T_TIP);
        jj_consume_token(WSP);
                            tooltip = Text();
        nl();
      } else {
        ;
      }
      if (testIndent(scope) && getToken(1).kind == T_SYS) {
        jj_consume_token(T_SYS);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WSP:
          jj_consume_token(WSP);
          SystemName();
          nl();
          break;
        case 0:
        case NL:
          nl();
          label_3:
          while (true) {
                       assertIndent(scope + 1);
            SystemName();
            nl();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case T_LINUX:
            case T_OSX:
            case T_SOLARIS:
            case T_UNIX:
            case T_WINDOWS:
            case T_ALL:
              ;
              break;
            default:
              jj_la1[1] = jj_gen;
              break label_3;
            }
          }
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        ;
      }
      if (testIndent(scope) && getToken(1).kind == T_EXEC) {
        jj_consume_token(T_EXEC);
        jj_consume_token(WSP);
                            exec    = Text();
        nl();
      } else {
        ;
      }
      if (testIndent(scope) && getToken(1).kind == T_DATABASE) {
        mainConnection = ParseDBConnect();
        nl();
      } else {
        ;
      }
      widgetList = Body(scope, pcdio);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new PCDObject(path, name, exec, icon,
                           tooltip, systems, widgetList);}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <p>Parses PCD menu item content</p>
 * <p>The format for a PCD menu item is:</p>
 * <pre>
 *     [ Optional Blank Space ]
 *     [ PCD Options ]<br />
 *     Tabs and Parameters</pre>
 **
 * @param scope the scope to parse the objects in
 * @param pcdio the PCD I/O object for all temporary files to interact with
 */
  final public Map<String, Widget> Body(int scope, PCDIO pcdio) throws ParseException {
 /*@bgen(jjtree) Body */
  ASTBody jjtn000 = new ASTBody(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      masterWidgetList = new LinkedHashMap<String, Widget>();
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_ACT:
        case T_PARAM:
        case T_TABSET:
        case T_PANEL:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_4;
        }
        Content(scope, masterWidgetList, pcdio);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 0:
        jj_consume_token(0);
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return masterWidgetList;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <p>Parses PCD file content</p>
 * <p>PCD file content can be any of the following:</p>
 * <pre>
 *     Tabs, panels, action (buttons) and Parameters</pre>
 **
 * @param scope      the scope to parse the objects in
 * @param widgetList the list of all widgets within
 *                   the current BioPCD menu item body
 * @param pcdio      the PCD I/O object for all temporary
 *                   files to interact with
 */
  final public void Content(int scope, Map<String, Widget> widgetList, PCDIO pcdio) throws ParseException {
 /*@bgen(jjtree) Content */
  ASTContent jjtn000 = new ASTContent(JJTCONTENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_PARAM:
        Param(scope, widgetList, pcdio);
        break;
      case T_ACT:
        Act(scope, widgetList);
        break;
      case T_TABSET:
        Tab(scope, widgetList, pcdio);
        break;
      case T_PANEL:
        Panel(scope, widgetList, pcdio);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

/**
 * <p>
 *    Generates a tabbed pane based on reading the tab tag from the PCD file.
 * </p>
 * <p>
 *    This function reads the &lt;T_TAB&gt; tag, parses the name, and creates a
 *    new panel object that all sub-components can be added to.  The tab
 *    is then added to a tabbed pane in the main window.
 * </p>
 * <p>
 *    Each tab can only contain paramter objects,
 *    and each tab MUST contain at least one parameter object.
 * </p>
 **
 * @param scope the scope to parse the tabset object into
 * @param widgetList the list of widgets to add the tab to
 * @param pcdio the PCD I/O object for all temporary files to interact with
 */
  final public void Tab(int scope, Map<String, Widget> widgetList, PCDIO pcdio) throws ParseException {
                                                                    /*@bgen(jjtree) Tab */
    ASTTab jjtn000 = new ASTTab(JJTTAB);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* Temporarily stores parameters before they are added to the main panel */
    Map<String, Widget> tabParameterList = new LinkedHashMap<String, Widget>();
    /* The current tabset to add to biolegato's menu system*/
    TabbedWidget tabset = null  ;
    try {
      assertIndent(scope);
      jj_consume_token(T_TABSET);
      nl();
        tabset = new TabbedWidget();
        widgetList.put("____tab" + widgetList.size(), tabset);
      label_5:
      while (true) {
        jj_consume_token(T_TAB);
        jj_consume_token(WSP);
                          tabset.addTab(Text(), tabParameterList);
        nl();
        label_6:
        while (true) {
          Content(scope + 2,
                                                              tabParameterList, pcdio);
          if (testIndent(scope + 2)) {
            ;
          } else {
            break label_6;
          }
        }
            tabParameterList = new LinkedHashMap<String, Widget>();
        if (testIndent(scope + 1)) {
          ;
        } else {
          break label_5;
        }
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

/**
 * <p>
 *    Generates a non-tabbed panel based on reading the panel tag from the PCD
 *    file.
 * </p>
 * <p>
 *    This function reads the &lt;T_PANEL&gt; tag, parses it,
 *    and creates a panel.
 * </p>
 * <p>
 *    Panels are used so related parameters can be positioned together
 *    for example, related buttons can be positioned side by side.
 * </p>
 **
 * @param scope the scope to parse the panel object into
 * @param widgetList the list of widgets to add the panel to
 * @param pcdio the PCD I/O object for all temporary files to interact with
 */
  final public void Panel(int scope, Map<String, Widget> widgetList, PCDIO pcdio) throws ParseException {
                                                                      /*@bgen(jjtree) Panel */
    ASTPanel jjtn000 = new ASTPanel(JJTPANEL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* The panel widget list to add parameters to */
    Map<String, Widget> panelWidgetList = new LinkedHashMap<String, Widget>();
    try {
      assertIndent(scope);
      jj_consume_token(T_PANEL);
      nl();
      label_7:
      while (true) {
        Content(scope + 1,
                                                         panelWidgetList, pcdio);
        if (testIndent(scope + 1)) {
          ;
        } else {
          break label_7;
        }
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      widgetList.put("___panel" + widgetList.size(),
                     new PanelWidget(panelWidgetList));
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

/**
 * <p>
 *    Generates a parameter component according to the PCD file's
 *    &lt;T_ACT&gt; production(s).
 * </p>
 * <p>
 *    This function reads the &lt;T_ACT&gt; tag, and creates a new button
 *    for running commands in BioLegato.
 * </p>
 **
 * @param scope the scope to parse the action object in
 * @param widgetList the list of widgets to add the action to
 */
  final public void Act(int scope, Map<String, Widget> widgetList) throws ParseException {
 /*@bgen(jjtree) Act */
    ASTAct jjtn000 = new ASTAct(JJTACT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* the label for the field */
    String label = "";
    /* the shell command to run */
    String shell = "";
    /* whether the button should close the command window */
    boolean close = false;
    try {
      assertIndent(scope);
      jj_consume_token(T_ACT);
      jj_consume_token(WSP);
      label = Text();
      nl();
      assertIndent(scope + 1);
      jj_consume_token(T_SHELL);
      jj_consume_token(WSP);
      shell = Text();
      nl();
      if (testIndent(scope + 1)) {
        jj_consume_token(T_CLOSE);
        jj_consume_token(WSP);
        close = Bool();
        nl();
      } else {
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      widgetList.put("___act" + label, new CommandButton("___act" + label,
                            masterWidgetList, label, shell, close));
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
  }

/**
 * <p>
 *      Generates a parameter component according to the PCD file's
 *      &lt;T_PARAM&gt; production(s).
 * </p>
 * <p>
 *      This function reads the &lt;T_PARAM&gt; tag, parses the name, and
 *      creates a new parameter component corresponding to the type of parameter
 *      read.
 * </p>
 * <p>
 *      Each parameter MUST contain a type as its first field!
 * </p>
 * <p>
 *      Currently the following types are supported:
 * </p>
 * <table>
 *  <tr><th>Type field</th><th>Description</th> </tr>
 *  <tr><td>button</td>    <td>Buttons which can run commands or perform
                               functions</td> </tr>
 *  <tr><td>list</td>      <td>A JList containing options</td> </tr>
 *  <tr><td>chooser</td>   <td>A radio button field</td> </tr>
 *  <tr><td>text</td>      <td>A text-field</td> </tr>
 *  <tr><td>number</td>    <td>A slider/spinner combination to set numbers</td>
 *                                                                        </tr>
 *  <tr><td>decimal</td>   <td>A decimal number widget</td> </tr>
 *  <tr><td>file</td>      <td>A file used for I/O</td> </tr>
 *  <tr><td>dir</td>       <td>A directory used for file I/O</td> </tr>
 * </table>
 **
 * @param scope the scope to parse the parameter object in
 * @param widgetList the list of widgets to add the parameter to
 * @param pcdio the PCD I/O object for all temporary files to interact with
 */
  final public void Param(int scope, Map<String, Widget> widgetList, PCDIO pcdio) throws ParseException {
 /*@bgen(jjtree) Param */
    ASTParam jjtn000 = new ASTParam(JJTPARAM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* The name of the parameter (for variable reference) */
    String name;

    /* Temporarily stores parameters before they are returned */
    Widget parameter = null;
    try {
      assertIndent(scope);
      jj_consume_token(T_PARAM);
      jj_consume_token(WSP);
      name = Text();
      nl();
      assertIndent(scope + 1);
      jj_consume_token(T_TYPE);
      jj_consume_token(WSP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_BUTTON:
        jj_consume_token(T_BUTTON);
        nl();
        parameter = buttonFields(scope + 1, name);
        break;
      case T_CHOOSER:
        jj_consume_token(T_CHOOSER);
        nl();
        parameter = listFields(scope + 1, name, ListType.CHOOSER);
        break;
      case T_COMBOBOX:
        jj_consume_token(T_COMBOBOX);
        nl();
        parameter = listFields(scope + 1, name, ListType.COMBOBOX);
        break;
      case T_LIST:
        jj_consume_token(T_LIST);
        nl();
        parameter = listFields(scope + 1, name, ListType.LIST);
        break;
      case T_TEXT:
        jj_consume_token(T_TEXT);
        nl();
        parameter = textFields(scope + 1, name);
        break;
      case T_TEXTAREA:
        jj_consume_token(T_TEXTAREA);
        nl();
        parameter = textAreaFields(scope + 1, name);
        break;
      case T_NUMBER:
        jj_consume_token(T_NUMBER);
        nl();
        parameter = numberFields(scope + 1, name);
        break;
      case T_DECIMAL:
        jj_consume_token(T_DECIMAL);
        nl();
        parameter = decimalFields(scope + 1, name);
        break;
      case T_FILE:
        jj_consume_token(T_FILE);
        nl();
        parameter = fileFields(scope + 1, name);
        break;
      case T_DIR:
        jj_consume_token(T_DIR);
        nl();
        parameter = dirFields(scope + 1, name);
        break;
      case T_TEMPFILE:
        jj_consume_token(T_TEMPFILE);
        nl();
        parameter = tempfileFields(scope + 1, name, pcdio);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      widgetList.put(name, parameter);
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

/**
 * Parses all of the fields that should be part of any button field
 **
 * @param scope the scope level to read the objects at
 * @param name the name of the widget
 * @return the button widget object
 */
  final public Widget buttonFields(int scope, String name) throws ParseException {
 /*@bgen(jjtree) buttonFields */
    ASTbuttonFields jjtn000 = new ASTbuttonFields(JJTBUTTONFIELDS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* the label for the field */
    String label = "";
    /* the shell command to run */
    String shell = "";
    /* whether the button should close the command window */
    boolean close = false;
    try {
      assertIndent(scope);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_LABEL:
        jj_consume_token(T_LABEL);
        jj_consume_token(WSP);
        label = Text();
        nl();
        assertIndent(scope);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      jj_consume_token(T_SHELL);
      jj_consume_token(WSP);
      shell = Text();
      nl();
      if (testIndent(scope)) {
        jj_consume_token(T_CLOSE);
        jj_consume_token(WSP);
        close = Bool();
        nl();
      } else {
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new CommandButton(name, masterWidgetList, label, shell, close);}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses all of the fields that should be part of any list object
 **
 * @param  scope the scope level to read the objects at
 * @param  name the name of the widget
 * @param  lType the type of list object to create
 * @return the list widget object
 */
  final public Widget listFields(int scope, String name, ListType lType) throws ParseException {
 /*@bgen(jjtree) listFields */
    ASTlistFields jjtn000 = new ASTlistFields(JJTLISTFIELDS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* the label for the field */
    String label = "";
    /* The default for the text field */
    int value = 0;
    /* The name  of the current choice to add to the choices hashtable */
    String choiceName;
    /* The value of the current choice to add to the choices hashtable */
    String choiceValue;
    /**
     * Used for storing variable choice names
     */
    List<String> choicenames = new LinkedList<String>();
    /**
     * Used for storing variable choice values
     */
    List<String> choicevalues = new LinkedList<String>();
    /**
     * The list widget parsed by the function call
     */
    ListWidget result = null;
    /**
     * Used to store an optional SQL query to obtain the list choices from
     */
    PCDSQL query = null;
    try {
      assertIndent(scope);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_LABEL:
        jj_consume_token(T_LABEL);
        jj_consume_token(WSP);
                            label = Text();
        nl();
                                                       assertIndent(scope);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_DEFAULT:
        jj_consume_token(T_DEFAULT);
        jj_consume_token(WSP);
                            value = Number();
        nl();
                                                       assertIndent(scope);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      jj_consume_token(T_CHOICES);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WSP:
        jj_consume_token(WSP);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_QUERY:
          jj_consume_token(T_QUERY);
          jj_consume_token(WSP);
                              query = new PCDSQL(mainConnection,
                                                 Text(), false);
          break;
        case T_DATABASE:
          query = FullSQLQuery();
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                if (lType == ListType.CHOOSER) {
                    result = new Chooser(name, label, query, value);
                } else if (lType == ListType.LIST) {
                    result = new ChoiceList(name, label, query, value);
                } else {
                    result = new ComboBoxWidget(name, label, query, value);
                }
        nl();
        break;
      case 0:
      case NL:
        nl();
        label_8:
        while (true) {
          choiceName = Text();
          jj_consume_token(WSP);
          choiceValue = Text();
          nl();
                      choicenames.add(choiceName);
                      choicevalues.add(choiceValue);
          if (testIndent(scope + 1)) {
            ;
          } else {
            break label_8;
          }
        }
                String[] choicevaluearray = choicevalues.toArray(ListWidget.BLANK_STRING_ARRAY);
                String[] choicenamearray  = choicenames.toArray(ListWidget.BLANK_STRING_ARRAY);

                if (lType == ListType.CHOOSER) {
                    result = new Chooser(name, label, choicenamearray,
                                         choicevaluearray, value);
                } else if (lType == ListType.LIST) {
                    result = new ChoiceList(name, label, choicenamearray,
                                            choicevaluearray, value);
                } else {
                    result = new ComboBoxWidget(name, label, choicenamearray,
                                                choicevaluearray, value);
                }
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        {if (true) return result;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses all of the fields that should be part of any text field
 **
 * @param scope the scope level to read the objects at
 * @param name the name of the widget
 * @return the text widget object
 */
  final public Widget textFields(int scope, String name) throws ParseException {
 /*@bgen(jjtree) textFields */
    ASTtextFields jjtn000 = new ASTtextFields(JJTTEXTFIELDS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* the label for the field */
    String label = "";
    /* The default for the text field */
    String value = "";
    try {
      if (jj_2_1(2147483647)) {
                               assertIndent(scope);
        jj_consume_token(T_LABEL);
        jj_consume_token(WSP);
        label = Text();
        nl();
      } else {
        ;
      }
      if (jj_2_2(2147483647)) {
                               assertIndent(scope);
        jj_consume_token(T_DEFAULT);
        jj_consume_token(WSP);
        value = Text();
        nl();
      } else {
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new TextWidget(name, label, value);}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses all of the fields that should be part of any textarea
 **
 * @param scope the scope level to read the objects at
 * @param name the name of the widget
 * @return the text widget object
 */
  final public Widget textAreaFields(int scope, String name) throws ParseException {
 /*@bgen(jjtree) textAreaFields */
    ASTtextAreaFields jjtn000 = new ASTtextAreaFields(JJTTEXTAREAFIELDS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* the label for the field */
    String label = "";
    /* The default for the textarea */
    String value = "";
    /* Determines whether or not to delete the file after execution. */
    boolean save = false;
    try {
      if (jj_2_3(2147483647)) {
                               assertIndent(scope);
        jj_consume_token(T_LABEL);
        jj_consume_token(WSP);
        label = Text();
        nl();
      } else {
        ;
      }
      if (jj_2_4(2147483647)) {
                               assertIndent(scope);
        jj_consume_token(T_DEFAULT);
        jj_consume_token(WSP);
        value = Text();
        nl();
      } else {
        ;
      }
      if (jj_2_5(2147483647)) {
                               assertIndent(scope);
        jj_consume_token(T_SAVE);
        jj_consume_token(WSP);
                                                                          save=Bool();
        nl();
      } else {
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new TextAreaWidget(name, label, value, save);}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <p>Parses all of the fields that should be part of any number field.</p>
 * <p><i>
 *      NOTE: the default maximum value is 500,000 and the default minimum
 *            value is zero (0).
 * </i></p>
 **
 * @param scope the scope level to read the objects at
 * @param name the name of the widget
 * @return the number widget object
 */
  final public Widget numberFields(int scope, String name) throws ParseException {
 /*@bgen(jjtree) numberFields */
    ASTnumberFields jjtn000 = new ASTnumberFields(JJTNUMBERFIELDS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* the label for the field */
    String label = "";
    /* The minimum number allowed */
    int min      = 0;
    /* The maximum number allowed */
    int max      = 500000;
    /* The default for the number field */
    int value    = 0;
    try {
      assertIndent(scope);
      jj_consume_token(T_LABEL);
      jj_consume_token(WSP);
      label = Text();
      nl();
      assertIndent(scope);
      jj_consume_token(T_MIN);
      jj_consume_token(WSP);
      min = Number();
      nl();
      assertIndent(scope);
      jj_consume_token(T_MAX);
      jj_consume_token(WSP);
      max = Number();
      nl();
      if (jj_2_6(2147483647)) {
                               assertIndent(scope);
        jj_consume_token(T_DEFAULT);
        jj_consume_token(WSP);
        value = Number();
        nl();
      } else {
        ;
      }
      if (value < min) { value = min; }
      if (value > max) { value = max; }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new NumberWidget(name, label, min, max, value);}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses all of the fields that should be part of any decimal field
 **
 * @param scope the scope level to read the objects at
 * @param name the name of the widget
 * @return the decimal widget object
 */
  final public Widget decimalFields(int scope, String name) throws ParseException {
 /*@bgen(jjtree) decimalFields */
    ASTdecimalFields jjtn000 = new ASTdecimalFields(JJTDECIMALFIELDS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* the label for the field */
    String label = "";
    /* The minimum number allowed */
    double min;
    /* The maximum number allowed */
    double max;
    /* The default for the number field */
    double value;
    try {
      assertIndent(scope);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_LABEL:
        jj_consume_token(T_LABEL);
        jj_consume_token(WSP);
        label = Text();
        nl();
        assertIndent(scope);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      jj_consume_token(T_MIN);
      jj_consume_token(WSP);
      min = Decimal();
      nl();
      assertIndent(scope);
      jj_consume_token(T_MAX);
      jj_consume_token(WSP);
      max = Decimal();
      nl();
      if (jj_2_7(2147483647)) {
                               assertIndent(scope);
        jj_consume_token(T_DEFAULT);
        jj_consume_token(WSP);
        value = Decimal();
        nl();
      } else {
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new TextWidget(name, label, "");}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses all of the fields that should be part of any file chooser
 **
 * @param scope the scope level to read the objects at
 * @param name the name of the widget
 * @return the file widget object
 */
  final public Widget fileFields(int scope, String name) throws ParseException {
 /*@bgen(jjtree) fileFields */
    ASTfileFields jjtn000 = new ASTfileFields(JJTFILEFIELDS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* the label for the field */
    String label = "";
    /* The default for the text field */
    String value = "";
    try {
                               assertIndent(scope);
      jj_consume_token(T_LABEL);
      jj_consume_token(WSP);
      label = Text();
      nl();
      if (jj_2_8(2147483647)) {
                               assertIndent(scope);
        jj_consume_token(T_DEFAULT);
        jj_consume_token(WSP);
        value = Text();
        nl();
      } else {
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new FileChooser(name, label, value);}
    } catch (Throwable jjte000) {
                               if (jjtc000) {
                                 jjtree.clearNodeScope(jjtn000);
                                 jjtc000 = false;
                               } else {
                                 jjtree.popNode();
                               }
                               if (jjte000 instanceof RuntimeException) {
                                 {if (true) throw (RuntimeException)jjte000;}
                               }
                               if (jjte000 instanceof ParseException) {
                                 {if (true) throw (ParseException)jjte000;}
                               }
                               {if (true) throw (Error)jjte000;}
    } finally {
                               if (jjtc000) {
                                 jjtree.closeNodeScope(jjtn000, true);
                               }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses all of the fields that should be part of any directory chooser
 **
 * @param scope the scope level to read the objects at
 * @param name the name of the widget
 */
  final public Widget dirFields(int scope, String name) throws ParseException {
 /*@bgen(jjtree) dirFields */
    ASTdirFields jjtn000 = new ASTdirFields(JJTDIRFIELDS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* the label for the field */
    String label = "";
    /* The default for the text field */
    String value = "";
    try {
                               assertIndent(scope);
      jj_consume_token(T_LABEL);
      jj_consume_token(WSP);
      label = Text();
      nl();
      if (jj_2_9(2147483647)) {
                               assertIndent(scope);
        jj_consume_token(T_DEFAULT);
        jj_consume_token(WSP);
        value = Text();
        nl();
      } else {
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new DirectoryChooser(name, label, value);}
    } catch (Throwable jjte000) {
                               if (jjtc000) {
                                 jjtree.clearNodeScope(jjtn000);
                                 jjtc000 = false;
                               } else {
                                 jjtree.popNode();
                               }
                               if (jjte000 instanceof RuntimeException) {
                                 {if (true) throw (RuntimeException)jjte000;}
                               }
                               if (jjte000 instanceof ParseException) {
                                 {if (true) throw (ParseException)jjte000;}
                               }
                               {if (true) throw (Error)jjte000;}
    } finally {
                               if (jjtc000) {
                                 jjtree.closeNodeScope(jjtn000, true);
                               }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses all of the fields that should be part of any temporary file field
 **
 * @param scope the scope level to read the objects at
 * @param name the name of the widget
 * @param pcdio the PCD I/O object for the temporary file to interact with
 * @return the temp file widget object
 */
  final public Widget tempfileFields(int scope, String name, PCDIO pcdio) throws ParseException {
 /*@bgen(jjtree) tempfileFields */
    ASTtempfileFields jjtn000 = new ASTtempfileFields(JJTTEMPFILEFIELDS);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* Whether or not to add the contents of the window to the file before
     * execution.  (whether the temporary file is input for a program).    */
    boolean input = false;
    /* Whether or not to add the contents of the file to the window after
     *  execution.  (whether the temporary file is output for a program).  */
    boolean output = false;
    /* Determines whether or not to delete the file after execution. */
    boolean save = false;
    /* Determines whether or not to overwrite the file if it already exists. */
    boolean overwrite = false;
    /* Stores the file format of the file (used for translation). */
    String format = null;
    /* Stores whether the temporary file uses just the current selection
     * within the cavnas, or the entire data set stored in biolegato
     * (the equivalent of Select-all)                                       */
    boolean selectall = false;
    try {
        assertIndent(scope);
      jj_consume_token(T_DIRECTION);
      jj_consume_token(WSP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_IN:
        jj_consume_token(T_IN);
                       input = true;
        break;
      case T_OUT:
        jj_consume_token(T_OUT);
                                                       output = true;
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      nl();
        assertIndent(scope);
      jj_consume_token(T_FORMAT);
      jj_consume_token(WSP);
                                                        format=FileFormat();
      nl();
      if (jj_2_10(2147483647)) {
                                 assertIndent(scope);
        jj_consume_token(T_SAVE);
        jj_consume_token(WSP);
                                                                              save=Bool();
        nl();
      } else {
        ;
      }
      if (jj_2_11(2147483647)) {
                                 assertIndent(scope);
        jj_consume_token(T_OVERWRITE);
        jj_consume_token(WSP);
                                                                              overwrite=Bool();
        nl();
      } else {
        ;
      }
      if (jj_2_12(2147483647)) {
                                 assertIndent(scope);
        jj_consume_token(T_CONTENT);
        jj_consume_token(WSP);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case T_CANVAS:
          jj_consume_token(T_CANVAS);
                                                                                           selectall = true;
          break;
        case T_SELECTION:
          jj_consume_token(T_SELECTION);
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        nl();
      } else {
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new TempFile(name, pcdio, input, output, save, overwrite, format, selectall);}
    } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          {if (true) throw (RuntimeException)jjte000;}
        }
        if (jjte000 instanceof ParseException) {
          {if (true) throw (ParseException)jjte000;}
        }
        {if (true) throw (Error)jjte000;}
    } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses file formats supported by BioPCD
 **
 * @return the text representation of the file format
 */
  final public String FileFormat() throws ParseException {
 /*@bgen(jjtree) FileFormat */
    ASTFileFormat jjtn000 = new ASTFileFormat(JJTFILEFORMAT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);String result = "raw";
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_CSV:
        jj_consume_token(T_CSV);
                     result = "csv"     ;
        break;
      case T_TSV:
        jj_consume_token(T_TSV);
                     result = "tsv"     ;
        break;
      case T_FASTA:
        jj_consume_token(T_FASTA);
                     result = "fasta"   ;
        break;
      case T_FLAT:
        jj_consume_token(T_FLAT);
                     result = "flat"    ;
        break;
      case T_GDE:
        jj_consume_token(T_GDE);
                     result = "gde"     ;
        break;
      case T_GENBANK:
        jj_consume_token(T_GENBANK);
                     result = "genbank" ;
        break;
      case T_RAW:
        jj_consume_token(T_RAW);
                     result = "raw"     ;
        break;
      case T_MASK:
        jj_consume_token(T_MASK);
                     result = "mask"    ;
        break;
      case TEXT:
        result = Text();
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return result;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <p>Parses a list of supported operating systems in a PCD file</p>
 * <p>
 *      The list is then compared with the current operating system
 *      to see if it is supported by the PCD command.  The comparison
 *      is done in another function (isSystemSupported).
 * </p>
 * <p>Currently supported operating systems:</p>
 * <pre>
 *      ALL     (the command supports any operating system)
 *      Linux
 *      OSX
 *      Solaris
 *      Unix    (the command will only work in UNIX-compatible systems)
 *      Windows (the command will only work in Windows-compatible systems)</pre>
 */
  final public SystemToken SystemName() throws ParseException {
 /*@bgen(jjtree) SystemName */
    ASTSystemName jjtn000 = new ASTSystemName(JJTSYSTEMNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* Stores the status of whether the current operating system is
     * supported by the software represented in the PCD file */
    SystemToken.OS osSupported = SystemToken.OS.ALL;

    /* Stores the status of whether the current machine architecture is
     * supported by the software represented in the PCD file */
    Set<SystemToken.ARCH> archSupported = Collections.singleton(SystemToken.ARCH.ALL);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_ALL:
        jj_consume_token(T_ALL);
                    osSupported = SystemToken.OS.ALL;
        break;
      case T_LINUX:
        jj_consume_token(T_LINUX);
                    osSupported = SystemToken.OS.LINUX;
        break;
      case T_OSX:
        jj_consume_token(T_OSX);
                    osSupported = SystemToken.OS.OSX;
        break;
      case T_SOLARIS:
        jj_consume_token(T_SOLARIS);
                    osSupported = SystemToken.OS.SOLARIS;
        break;
      case T_UNIX:
        jj_consume_token(T_UNIX);
                    osSupported = SystemToken.OS.UNIX;
        break;
      case T_WINDOWS:
        jj_consume_token(T_WINDOWS);
                    osSupported = SystemToken.OS.WINDOWS;
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WSP:
        jj_consume_token(WSP);
        archSupported = ArchList();
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new SystemToken(osSupported, archSupported);}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <p>Parses a list of supported system architectures in a PCD file</p>
 * <p>
 *      The list is then compared with the current system architecture
 *      to see if it is supported by the PCD command.  This comparsion
 *      is performed by the function <code>isSystemSupported()</code>
 * </p>
 **
 * @return whether the current system architecture
 *         is supported by the PCD command
 */
  final public Set<SystemToken.ARCH> ArchList() throws ParseException {
 /*@bgen(jjtree) ArchList */
    ASTArchList jjtn000 = new ASTArchList(JJTARCHLIST);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* Stores the most-recently parsed architecture token*/
    SystemToken.ARCH a;
    /* Stores the architectures supported by the current command */
    Set<SystemToken.ARCH> archs = new HashSet<SystemToken.ARCH>();
    try {
      /* match each system architecture token and add it to
           * the list of supported system architectures */
          a = ArchName();
                   archs.add(a);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
        case WSP:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WSP:
          jj_consume_token(WSP);
          break;
        default:
          jj_la1[19] = jj_gen;
          ;
        }
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WSP:
          jj_consume_token(WSP);
          break;
        default:
          jj_la1[20] = jj_gen;
          ;
        }
        /* get the system architecture token */
                a = ArchName();
                       archs.add(a);
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return archs;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * <p>
 *      Matches an architecture name and returns the
 *      appropriate <code>SystemToken.ARCH</code> value.
 * </p>
 * <p>Currently supported machine architectures:</p>
 * <pre>
 *     ALL     (the command supports any machine architecture
 *              - may be useful for shell-scripts)
 *     X86     (any x86 compatible machine)
 *     AMD64   (any amd64 compatible machine)
 *     Sparc   (any amd64 compatible machine)</pre>
 **
 * @return whether the architecture is supported
 */
  final public SystemToken.ARCH ArchName() throws ParseException {
                                /*@bgen(jjtree) ArchName */
  ASTArchName jjtn000 = new ASTArchName(JJTARCHNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_ALL:
        jj_consume_token(T_ALL);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   {if (true) return SystemToken.ARCH.ALL;}
        break;
      case T_X86:
        jj_consume_token(T_X86);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   {if (true) return SystemToken.ARCH.X86;}
        break;
      case T_AMD64:
        jj_consume_token(T_AMD64);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   {if (true) return SystemToken.ARCH.AMD64;}
        break;
      case T_SPARC:
        jj_consume_token(T_SPARC);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   {if (true) return SystemToken.ARCH.SPARC;}
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an SQL database production
 **
 * @return the coresponding Java database connection object
 */
  final public JDBCDBConnection ParseDBConnect() throws ParseException {
 /*@bgen(jjtree) ParseDBConnect */
    ASTParseDBConnect jjtn000 = new ASTParseDBConnect(JJTPARSEDBCONNECT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/**
     * The database driver to connect to for the SQL query
     */
    String  driver     = null  ;
    /**
     * The database URL to connect to for the the SQL query
     */
    String  url        = null  ;
    /**
     * The database password to connect to for the SQL query
     */
    String  user       = null  ;
    /**
     * The database username to connect to for the SQL query
     */
    String  password   = null  ;
    try {
      jj_consume_token(T_DATABASE);
      jj_consume_token(WSP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXT:
        driver = Text();
        jj_consume_token(WSP);
        url = Text();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WSP:
          jj_consume_token(WSP);
          jj_consume_token(T_LOGIN);
          jj_consume_token(WSP);
          user = Text();
          jj_consume_token(WSP);
          password = Text();
          break;
        default:
          jj_la1[22] = jj_gen;
          ;
        }
        break;
      case T_MYSQL:
        jj_consume_token(T_MYSQL);
                   driver="com.mysql.jdbc.Driver";
        jj_consume_token(WSP);
          url="jdbc:mysql://" + Text();
        jj_consume_token(WSP);
                url += "/" + Text();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WSP:
          jj_consume_token(WSP);
          jj_consume_token(T_LOGIN);
          jj_consume_token(WSP);
          user = Text();
          jj_consume_token(WSP);
          password = Text();
          break;
        default:
          jj_la1[23] = jj_gen;
          ;
        }
        break;
      case T_HSQLDB:
        jj_consume_token(T_HSQLDB);
                   driver="org.hsqldb.jdbcDriver";
        jj_consume_token(WSP);
            url="jdbc:hsqldb:" + Text();
            user="sa";
            password="";
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WSP:
          jj_consume_token(WSP);
          jj_consume_token(T_LOGIN);
          jj_consume_token(WSP);
          user = Text();
          jj_consume_token(WSP);
          password = Text();
          break;
        default:
          jj_la1[24] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new JDBCDBConnection(driver, url, user, password);}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an SQL database production
 **
 * @return the coresponding Java database connection object
 */
  final public PCDSQL FullSQLQuery() throws ParseException {
 /*@bgen(jjtree) FullSQLQuery */
    ASTFullSQLQuery jjtn000 = new ASTFullSQLQuery(JJTFULLSQLQUERY);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/**
     * The database to connect to for the SQL query
     */
    JDBCDBConnection connection = null  ;
    try {
      connection = ParseDBConnect();
      jj_consume_token(WSP);
      jj_consume_token(T_QUERY);
      jj_consume_token(WSP);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return new PCDSQL(connection, Text(), true);}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses an identifier token from a PCD file into a Java String
 **
 * @return the coresponding Java String object
 */
  final public String Ident() throws ParseException {
 /*@bgen(jjtree) Ident */
    ASTIdent jjtn000 = new ASTIdent(JJTIDENT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* The token to parse into a String value */
    Token t = null;
    try {
      /* Match a text token */
          t = jj_consume_token(ID);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return t.image;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a text token from a PCD file into a Java String.
 * Supports environment variable substitution into the string,
 * where the environment variable is of the form:
 * "\"\\$([a-zA-Z])([a-zA-Z_\\-0-9@\\.])*\""
 * Example: "$BL_EMAIL"
 **
 * @return the corresponding Java String object
 */
  final public String Text() throws ParseException {
 /*@bgen(jjtree) Text */
    ASTText jjtn000 = new ASTText(JJTTEXT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* The token to parse into a String value */
    Token t = null;
    String retstr = "";
    try {
      /* Match a text token */
          t = jj_consume_token(TEXT);
        /* Find the Start and Finish indices of a substring matching the pattern
           for an environment variable. */
        retstr = PCD.textString(t.image);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return retstr;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a decimal number from a PCD file into a Java double
 **
 * @return the corresponding Java double value
 */
  final public double Decimal() throws ParseException {
 /*@bgen(jjtree) Decimal */
    ASTDecimal jjtn000 = new ASTDecimal(JJTDECIMAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* The double value parsed by the function */
    double value = 0d;

    /* The token to parse into a double value */
    Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL:
        t = jj_consume_token(DECIMAL);
           String tokenstr;
            if (t.image.charAt(0) == '$') { //get decimal from environment variable
                tokenstr = System.getenv(t.image.substring(1));
            }
            else {
                tokenstr = t.image;
            }
            //System.out.println(tokenstr);
            try {
                value = Double.parseDouble(tokenstr);
            } catch (NumberFormatException nfe) {
                /* NOTE: this statement should never be reached because the
	         *       token manager will only pass proper decimal numbers
		 *       to this code; however, Java requires a try-catch
		 *       clause in order to parse Strings into doubles */
                {if (true) throw new ParseException("Invalid decimal number on line: " +
                    t.endLine);}
            }
        break;
      case NUMBER:
        value = Number();
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return value;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a non-decimal number from a PCD file into a Java integer
 **
 * @return the corresponding Java int value
 */
  final public int Number() throws ParseException {
 /*@bgen(jjtree) Number */
    ASTNumber jjtn000 = new ASTNumber(JJTNUMBER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);/* The integer value parsed by the function */
    int value = 0;

    /* The token to parse into an integer value */
    Token t = null;
    try {
      /* Match the number token to parse */
              t = jj_consume_token(NUMBER);
        String tokenstr;
        if (t.image.charAt(0) == '$') { //get number from environment variable
            tokenstr = System.getenv(t.image.substring(1));
        }
        else {
            tokenstr = t.image;
        }
        //System.out.println(tokenstr);
            try {
                value = Integer.parseInt(tokenstr);
            } catch (NumberFormatException nfe) {
                /* NOTE: this statement should never be reached because the
                 *       token manager will only pass proper numbers to this
                 *       code; however, Java requires a try-catch clause in
                 *       order to parse Strings into integers */
                {if (true) throw new ParseException("Invalid number on line: " +
                    t.endLine);}
            }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return value;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Parses a boolean token into a java boolean
 **
 * @return the value of the boolean
 */
  final public boolean Bool() throws ParseException {
                   /*@bgen(jjtree) Bool */
  ASTBool jjtn000 = new ASTBool(JJTBOOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case T_TRUE:
        jj_consume_token(T_TRUE);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  {if (true) return true;}
        break;
      case T_FALSE:
        jj_consume_token(T_FALSE);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  {if (true) return false;}
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Asserts indentation level (calls token_source.testIndent)
 **
 * @param scope the number of indents required
 */
  final public void assertIndent(int scope) throws ParseException {
        if (!testIndent(scope)) {
            {if (true) throw new ParseException("Indentation error on line: "
                + getToken(1).beginLine + " with an indentation of "
                + (token_source.getIndent() * token_source.INDENT_SIZE)
                + " spaces (expected "
                + (scope * token_source.INDENT_SIZE) + " spaces)");}
        }
  }

/**
 * Tests indentation (NOTE: this calls the token manager)
 **
 * @param scope the number of indents required
 */
  final public boolean testIndent(int scope) throws ParseException {
      getToken(1);
      {if (true) return (token_source.getIndent() == scope && getToken(1).kind != EOF);}
    throw new Error("Missing return statement in function");
  }

/**
 * Matches new line characters including preceding whitespace
 */
  final public void nl() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WSP:
      jj_consume_token(WSP);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NL:
      jj_consume_token(NL);
      break;
    case 0:
      jj_consume_token(0);
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_3_5() {
    if (jj_scan_token(T_SAVE)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_scan_token(T_DEFAULT)) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_scan_token(T_DEFAULT)) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_scan_token(T_DEFAULT)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(T_LABEL)) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_scan_token(T_DEFAULT)) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_scan_token(T_DEFAULT)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(T_LABEL)) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_scan_token(T_CONTENT)) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_scan_token(T_OVERWRITE)) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_scan_token(T_SAVE)) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(T_DEFAULT)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public PCDTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[30];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x1,0x1f000,0x1,0x0,0x1,0x0,0xffe,0x0,0x0,0x0,0x0,0x1,0x0,0xc0000000,0x0,0x3fc00000,0x1f000,0x0,0x0,0x0,0x0,0xe0000,0x0,0x0,0x0,0x0,0x0,0x300000,0x0,0x1,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0xc00000,0x0,0x0,0x0,0x18000,0x0,0x20000000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x6000000,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x28000,0x0,0x28000,0x170,0x0,0x170,0x0,0x1,0x1,0x0,0x0,0x28000,0x1,0x0,0x0,0x400,0x0,0x20000,0x20200,0x20000,0x20000,0x0,0x20000,0x20000,0x20000,0x400,0x1800,0x0,0x20000,0x8000,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[12];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public PCD(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public PCD(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new PCDTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public PCD(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new PCDTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public PCD(PCDTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(PCDTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 30; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[95];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 30; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 95; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 12; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
